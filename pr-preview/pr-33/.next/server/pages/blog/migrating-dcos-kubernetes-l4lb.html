<!DOCTYPE html><html lang="en"><head><script async="" src="https://www.google-analytics.com/analytics.js"></script><link rel="stylesheet" href="https://d381m57et8llfk.cloudfront.net/20210128-6054/static/css/dc7f55cf12b36887a247.fonts.css"/><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
                ga('create', 'UA-49472651-19', { 'storage': 'none' });
                ga('send', 'pageview');</script><script src="https://unpkg.com/react-bootstrap@next/dist/react-bootstrap.min.js"></script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Migrating from DCOS to Kubernetes, dealing with the l4lb loadbalancer</title><meta name="Description" content="When you want minimal downtime, you need to build your own tools"/><meta property="og:title" content="Migrating from DCOS to Kubernetes, dealing with the l4lb loadbalancer"/><meta property="og:description" content="When you want minimal downtime, you need to build your own tools"/><meta property="og:image" content="https://www.vandebron.tech/images/migrating-dcos-kubernetes-l4lb.jpg"/><meta name="next-head-count" content="7"/><link rel="preload" href="/pr-preview/pr-33/_next/static/css/f21f13bbd0dcf4e9a192.css" as="style"/><link rel="stylesheet" href="/pr-preview/pr-33/_next/static/css/f21f13bbd0dcf4e9a192.css" data-n-g=""/><link rel="preload" href="/pr-preview/pr-33/_next/static/css/93bdda6e46afdf643a2d.css" as="style"/><link rel="stylesheet" href="/pr-preview/pr-33/_next/static/css/93bdda6e46afdf643a2d.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/pr-preview/pr-33/_next/static/chunks/webpack-0b9cc56c94819e8023ea.js" as="script"/><link rel="preload" href="/pr-preview/pr-33/_next/static/chunks/framework.87b9127d6cd191ae1c9a.js" as="script"/><link rel="preload" href="/pr-preview/pr-33/_next/static/chunks/3ef630e34cd10ba68f9d468ac363ff81c534e1e9.e3444f50a0a795e3eeb2.js" as="script"/><link rel="preload" href="/pr-preview/pr-33/_next/static/chunks/main-419ac17f185f95278b96.js" as="script"/><link rel="preload" href="/pr-preview/pr-33/_next/static/chunks/7b9503d2.4af90216c47085b5c8e9.js" as="script"/><link rel="preload" href="/pr-preview/pr-33/_next/static/chunks/0357a89c.a83a6a4548b93404854d.js" as="script"/><link rel="preload" href="/pr-preview/pr-33/_next/static/chunks/226daff62b2d4bc1e9a7210a7f6000a544319a74.fbdd4d016a5c47ddc9db.js" as="script"/><link rel="preload" href="/pr-preview/pr-33/_next/static/chunks/pages/_app-fdd34d89c08fa14a1e57.js" as="script"/><link rel="preload" href="/pr-preview/pr-33/_next/static/chunks/1c49f5f00355f650bee3d37484f094be037a30fa.0c099ecf2acefc71ba39.js" as="script"/><link rel="preload" href="/pr-preview/pr-33/_next/static/chunks/pages/blog/%5Bslug%5D-d612e1337a48eb1a935c.js" as="script"/></head><body><div id="__next"><div class="Container-module__container" as="header" style="padding-top:30px;padding-bottom:30px;margin-bottom:30px"><div class="Row-module__row Row-module__align-items-center Row-module__justify-content-between"><div class="Col-module__col-box-sizing Col-module__col Col-module__col-12 Col-module__col-md-auto Col-module__col-lg-auto Col-module__col-sm-12"><div><div style="cursor:pointer;user-select:none;display:flex;align-items:baseline"><svg width="140" viewBox="0 0 140 22" xmlns="http://www.w3.org/2000/svg"><path d="M9.569 21.109h-4.25L0 6.274h4.597l2.86 9.249 2.86-9.249h4.598L9.57 21.11m13.234-4.258a3.159 3.159 0 0 1 0-6.316 3.156 3.156 0 0 1 3.144 2.884v.543a3.157 3.157 0 0 1-3.144 2.889m3.2-9.81a7.38 7.38 0 1 0 0 13.3c.136.425.537.73 1.003.73h3.174V6.313h-3.174c-.466 0-.867.304-1.003.728m64.522 3.567a3.155 3.155 0 0 0-3.141 2.888v.542a3.155 3.155 0 0 0 3.14 2.885 3.16 3.16 0 0 0 3.165-3.157 3.163 3.163 0 0 0-3.164-3.158m0 10.536a7.337 7.337 0 0 1-3.195-.727 1.056 1.056 0 0 1-1.006.727h-3.171V0h4.23v7.09a7.377 7.377 0 0 1 10.522 6.676c.001 4.074-3.298 7.378-7.38 7.378m26.406-4.22a3.155 3.155 0 0 1-3.141-2.886v-.542a3.155 3.155 0 0 1 3.141-2.888 3.163 3.163 0 0 1 3.164 3.159 3.161 3.161 0 0 1-3.164 3.156m.012-10.511c-5.054 0-7.481 3.978-7.481 7.356v.025c0 3.402 2.427 7.38 7.48 7.38 5.054 0 7.48-3.978 7.48-7.38 0-3.403-2.426-7.381-7.48-7.381m-60.448 4.196a3.155 3.155 0 0 1 3.141 2.888v.542a3.156 3.156 0 0 1-3.141 2.885 3.16 3.16 0 0 1-3.165-3.157 3.163 3.163 0 0 1 3.165-3.158m0 10.536a7.377 7.377 0 0 1-7.381-7.378A7.377 7.377 0 0 1 59.635 7.09V0h4.23v21.144h-3.17c-.473 0-.866-.303-1.006-.727a7.342 7.342 0 0 1-3.195.727zm51.349-14.856v4.222a3.074 3.074 0 0 0-.244-.013c-1.64 0-3.138 1.057-3.138 2.585v8.025h-4.234V6.276h3.17c.473 0 .867.303 1.006.727a7.353 7.353 0 0 1 3.196-.727c.082 0 .162.01.244.012zm25.525 4.21c-1.467 0-2.348.886-2.348 2.584v8.09h-4.285V6.277h3.172c.472 0 .865.304 1.005.727a7.347 7.347 0 0 1 3.195-.727s1.239-.059 2.514.343c3.027.904 3.379 3.962 3.379 5.599v8.955h-4.284v-8.091c0-.883-.205-2.585-2.348-2.585zm-93.333 0c-1.467 0-2.348.886-2.348 2.584v8.09h-4.284V6.277h3.17c.474 0 .866.304 1.006.727a7.354 7.354 0 0 1 3.196-.727s1.239-.059 2.514.343c3.028.904 3.378 3.962 3.378 5.599v8.955h-4.284v-8.091c0-.883-.204-2.585-2.348-2.585zm36.24 1.755h-5.453c-.116-.003-.55-.055-.325-.637a3.336 3.336 0 0 1 6.134.093c.147.495-.246.541-.356.544m2.55-3.796c-1.308-1.384-3.145-2.214-5.284-2.214-4.254 0-7.324 3.598-7.324 7.5 0 4.15 3.398 7.398 7.399 7.398a6.789 6.789 0 0 0 3.976-1.258c1.183-.806 2.165-2.013 2.844-3.574h-4.278c-.503.73-1.208 1.31-2.542 1.31-1.635 0-3.045-.983-3.22-2.468h10.393c.327-2.566-.202-4.806-1.964-6.694" fill="#333D47" fill-rule="evenodd"></path></svg> <span class="Text-module__text-default Text-module__u-font-h3 Text-module__u-font-color-green" style="font-size:28px;margin:0;line-height:auto">.tech</span></div></div></div><div class="Col-module__col-box-sizing Col-module__col Col-module__col-12 Col-module__col-md-auto Col-module__col-lg-auto Col-module__col-sm-12"><div class="Flex-module__d-flex Flex-module__flex-row Flex-module__align-items-stretch Flex-module__justify-content-start Flex-module__justify-content-sm-between"><ul class="Navigation-module__navigation-wrapper" id="styled-navigation" style="margin-right:25px"><li class="Navigation-module__navigation-link-wrapper"><a class="Pressable-module__button Pressable-module__text Navigation-module__navigation-link Navigation-module__navigation-link-active" name="Home" url="/"><span>Home</span></a></li><li class="Navigation-module__navigation-link-wrapper"><a class="Pressable-module__button Pressable-module__text Navigation-module__navigation-link" name="About" url="/about"><span>About</span></a></li><li class="Navigation-module__navigation-link-wrapper"><a class="Pressable-module__button Pressable-module__text Navigation-module__navigation-link" name="vandebron.nl" url="https://vandebron.nl"><span>vandebron.nl</span></a></li><div class="Navigation-module__navigation-magic-line" style="transition:none;left:0;width:0"></div></ul><div><a class="Pressable-module__button Pressable-module__text" href="https://github.com/vandebron/" target="_blank" rel="noreferrer" style="margin-right:10px"><svg role="img" viewBox="0 0 24 24" width="1em" height="1em" class="Icon-module__icon Icon-module__u-font-color-charcoal-gray" style="font-size:150%"><title>GitHub icon</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden">Vandebron on Github</span></a><a class="Pressable-module__button Pressable-module__text" href="https://dev.to/vandebron/" target="_blank" rel="noreferrer" style="margin-right:10px"><svg viewBox="0 0 448 512" width="1em" height="1em" class="Icon-module__icon Icon-module__u-font-color-charcoal-gray" style="font-size:150%"><path fill="currentColor" d="M120.12 208.29c-3.88-2.9-7.77-4.35-11.65-4.35H91.03v104.47h17.45c3.88 0 7.77-1.45 11.65-4.35 3.88-2.9 5.82-7.25 5.82-13.06v-69.65c-.01-5.8-1.96-10.16-5.83-13.06zM404.1 32H43.9C19.7 32 .06 51.59 0 75.8v360.4C.06 460.41 19.7 480 43.9 480h360.2c24.21 0 43.84-19.59 43.9-43.8V75.8c-.06-24.21-19.7-43.8-43.9-43.8zM154.2 291.19c0 18.81-11.61 47.31-48.36 47.25h-46.4V172.98h47.38c35.44 0 47.36 28.46 47.37 47.28l.01 70.93zm100.68-88.66H201.6v38.42h32.57v29.57H201.6v38.41h53.29v29.57h-62.18c-11.16.29-20.44-8.53-20.72-19.69V193.7c-.27-11.15 8.56-20.41 19.71-20.69h63.19l-.01 29.52zm103.64 115.29c-13.2 30.75-36.85 24.63-47.44 0l-38.53-144.8h32.57l29.71 113.72 29.57-113.72h32.58l-38.46 144.8z"></path></svg><span class="visually-hidden">Vandebron on Dev.to</span></a><a class="Pressable-module__button Pressable-module__text" href="https://medium.com/vandebron/" target="_blank" rel="noreferrer"><svg viewBox="0 0 448 512" width="1em" height="1em" class="Icon-module__icon Icon-module__u-font-color-charcoal-gray" style="font-size:150%"><path fill="currentColor" d="M0 32v448h448V32H0zm372.2 106.1l-24 23c-2.1 1.6-3.1 4.2-2.7 6.7v169.3c-.4 2.6.6 5.2 2.7 6.7l23.5 23v5.1h-118V367l24.3-23.6c2.4-2.4 2.4-3.1 2.4-6.7V199.8l-67.6 171.6h-9.1L125 199.8v115c-.7 4.8 1 9.7 4.4 13.2l31.6 38.3v5.1H71.2v-5.1l31.6-38.3c3.4-3.5 4.9-8.4 4.1-13.2v-133c.4-3.7-1-7.3-3.8-9.8L75 138.1V133h87.3l67.4 148L289 133.1h83.2v5z"></path></svg><span class="visually-hidden">Vandebron on Medium</span></a></div></div></div></div></div><div class="Container-module__container"><div class="Row-module__row"><div class="Col-module__col-box-sizing Col-module__col Col-module__col-12"><h2 class="Text-module__text-default Text-module__u-font-h2">Migrating from DCOS to Kubernetes, dealing with the l4lb loadbalancer</h2></div><div class="Col-module__col-box-sizing Col-module__col Col-module__col-12"><p class="Text-module__text-default Text-module__u-font-body"><span class="Text-module__text-default">By Rogier Dikkes on 5 maart 2021</span></p></div></div><div class="Row-module__row"><div class="Col-module__col-box-sizing Col-module__col Col-module__col-12"><p class="Text-module__text-default Text-module__u-font-body"><div class="Image-module__image-container" style="padding-bottom:50%"><div style="height:200px" class="lazyload-placeholder"></div></div><a class="Pressable-module__button Pressable-module__text" href="https://pixabay.com/users/praesentator-4372890/">Image source</a></p></div></div><div class="Row-module__row" style="margin-bottom:60px"><div class="Col-module__col-box-sizing Col-module__col Col-module__col-12"><p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">In October 2020 D2IQ <a href="https://d2iq.com/blog/d2iq-takes-the-next-step-forward" node="[object Object]" style="color:inherit" target="_blank">announced</a> that they are moving onwards with their Kubernetes offering. Vandebron has been a D2IQ customer for their DCOS offering, we were just in the middle of a migration of our first workloads to DCOS Enterprise. We have evaluated the D2IQ K8s offering and decided to go for another Kubernetes product. We had a few migrations over the years, we migrated from Azure to AWS, we migrated workloads from normal instances to spot instances and all these migrations were done with nearly any downtime. We plan to reduce the downtime to a couple of minutes this migration and this is a real challenge. The first challenge that we will discuss today: We want to pair our Kubernetes clusters to the DCOS/Mesos clusters, while we move a workload it should be able to connect to its dependencies in the DCOS cluster. We use DCOS for our NoSQL databases like Cassandra, internal data that we want to keep internal. Pairing DCOS and Kubernetes clusters enable us to reduce downtime, enabling us to switch back if we run into issues and move faster because it reduces complexity.</p>
<h2 class="Text-module__text-default Text-module__u-font-h2">L4LB</h2>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">The internal layer 4 load balancer DCOS provides is used in the majority of our workloads. When our data scientists schedule a spark driver, they connect to the spark dispatcher through the Layer 4 load balancer. Most of the DCOS frameworks use this Layer 4 load balancer as an internal service discovery tool, with Vandebron we use this layer 4 load balancer to communicate between services. In a default DCOS set up this load balancer responds on domain names like: <code style="background:rgb(0,0,0, 0.1);padding:2px 4px;font-size:80%;color:#000">spark-dispatcher.marathon.l4lb.thisdcos.directory:7077</code></p>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">When we ping the spark dispatcher we get the following:</p>
<pre><div style="color:#f8f8f2;background:#272822;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em"><code class="language-bash" style="color:#f8f8f2;background:none;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">PING spark-dispatcher.marathon.l4lb.thisdcos.directory (11.155.161.35) 56(84) bytes of data.
64 bytes from 11.155.161.35 (11.155.161.35): icmp_seq=1 ttl=64 time=0.024 ms</code></div></pre>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">After some investigation we found out that this IP range is not actually on a network interface, it is a Linux kernel functionality called <code style="background:rgb(0,0,0, 0.1);padding:2px 4px;font-size:80%;color:#000">IPVS</code>. With IPVS you can do layer 4 load balancing, you provide the target location and the location you want to respond on.</p>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">When we search for the IP from the spark dispatcher with ipvsadm, we get 3 results:</p>
<pre><div style="color:#f8f8f2;background:#272822;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em"><code class="language-bash" style="color:#f8f8f2;background:none;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">sudo ipvsadm -L -n |grep --color &#x27;11.155.161.35\|$&#x27;
TCP  11.155.161.35:80 wlc
  -&gt; 10.2.7.146:16827             Masq    1      0          0
TCP  11.155.161.35:4040 wlc
  -&gt; 10.2.7.146:16826             Masq    1      0          0
TCP  11.155.161.35:7077 wlc
  -&gt; 10.2.7.146:16825             Masq    1      0          0</code></div></pre>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">As you can see the IP <code style="background:rgb(0,0,0, 0.1);padding:2px 4px;font-size:80%;color:#000">11.155.161.35</code> points towards <code style="background:rgb(0,0,0, 0.1);padding:2px 4px;font-size:80%;color:#000">10.2.7.146</code>, even the ports are configured and forwarded. We can add our route with ipvsadm, to understand IPVS a bit better. For example:</p>
<pre><div style="color:#f8f8f2;background:#272822;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em"><code class="language-bash" style="color:#f8f8f2;background:none;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">sudo ipvsadm -A -t 1.2.3.4:80 -s wlc # we add the target server and assign the scheduler
sudo ipvsadm -a -r 10.2.7.146:16825 -t 1.2.3.4:80 -m # we configure the real server and target server and configure Masquerading
curl 1.2.3.4:80
{
  &quot;action&quot; : &quot;ErrorResponse&quot;,
  &quot;message&quot; : &quot;Missing protocol version. Please submit requests through http://[host]:[port]/v1/submissions/...&quot;,
  &quot;serverSparkVersion&quot; : &quot;2.3.4&quot;
}</code></div></pre>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">This results in that the spark dispatcher now also is available on <code style="background:rgb(0,0,0, 0.1);padding:2px 4px;font-size:80%;color:#000">1.2.3.4:80</code>. As mentioned before we wanted to connect our DCOS and Kubernetes clusters, getting hundreds of entries from ipvsadm and manually adding them one by one didn’t sound appealing to us. Especially if you consider that sometimes services fail and run on a different port or different host after recovery, maintaining this by hand would be a nightmare. We therefore decided to build a tool to sync IPVS entries from DCOS to Kubernetes.</p>
<h2 class="Text-module__text-default Text-module__u-font-h2">Stack</h2>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">Within Vandebron we have our tech stack, we strongly believe it is good to eat your own dog food. When possible and when our use cases are similar we use the same tools as our Developers use. The parts of the stack we will be using are:</p>
<ol style="margin-block-start:0;margin-block-end:30px">
<li class="Text-module__text-default Text-module__u-font-body" style="margin-bottom:0">AWS ELB in front of Traefik 1.7</li>
<li class="Text-module__text-default Text-module__u-font-body" style="margin-bottom:0">DCOS</li>
<li class="Text-module__text-default Text-module__u-font-body" style="margin-bottom:0">Kubernetes</li>
</ol>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">Within our platform team, we use Golang as our scripting language. Golang gives us the ability to build binary files with all the required libraries in the binary, we don’t have to install any packages, we do not even need to install Golang on the machine the application will be running on.</p>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">In our DCOS cluster we use Traefik 1.7, this version of Traefik only forwards HTTP requests. We decided to use Traefik to expose a JSON endpoint so we can gather the IPVS information from this location.</p>
<h2 class="Text-module__text-default Text-module__u-font-h2">ipvs-server</h2>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">Within our DCOS cluster we will expose the IPVS information through a JSON endpoint. We have built a tool for this to expose this information in multiple ways. In the next section, we are going to discuss some of the concepts and choices we made, we won’t deep dive into Go specifics. We have provided the entire code for this project in the examples directory of our GitHub repo:
<a href="https://github.com/Vandebron/tech-blog" node="[object Object]" style="color:inherit" target="_blank">https://github.com/Vandebron/tech-blog</a></p>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">First, let’s discuss the library we use: <a href="https://github.com/nanobox-io/golang-lvs" node="[object Object]" style="color:inherit" target="_blank">https://github.com/nanobox-io/golang-lvs</a>. This library in its essence translates to ipvsadm commands, it helped save us time to implement this ourselves. There are some gotcha’s, such as newlines are not filtered out from the output. We solved this by cleaning up some of the data.</p>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">In the <code style="background:rgb(0,0,0, 0.1);padding:2px 4px;font-size:80%;color:#000">childChan</code> function we create a go channel that is responsible for polling <code style="background:rgb(0,0,0, 0.1);padding:2px 4px;font-size:80%;color:#000">ipvsadm</code> every 10 seconds and stores the result in a couple of variables we use in our HTTP endpoints. IPVS is a Linux kernel functionality and should be highly performant, we do not want to trigger kernel panics when the server gets overloaded with requests. We expect that every 10 seconds gives us accurate enough results, we can always lower this interval to ensure faster results. We also added in this function the string manipulation to ensure all the newlines were gone in the JSON output. The newline gave issues when we tried to add the IPVS scheduler entries.</p>
<pre><div style="color:#f8f8f2;background:#272822;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em"><code class="language-go" style="color:#f8f8f2;background:none;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">func childChan(c chan bool) {
   fmt.Println(&quot;Starting time based IPVS Admin poll&quot;)

   pollInterval := 10
   timerCh := time.Tick(time.Duration(pollInterval) * time.Second)
   // Time based loop to generate Global variable
   for range timerCh {
       select {
       // when shutdown is received we break
       case &lt;-c:
           fmt.Println(&quot;Received shutdown, stopping timer&quot;)
           break
       default:
           var err error
           listIpvs.Save()
           ipvsString = fmt.Sprintln(listIpvs.Services)

           res := &amp;responseObject{
               Services: listIpvs.Services,
           }
 
           ipvsJSONbyte, err := json.Marshal(res)
           if err != nil {
               logToErr.Printf(&quot;ERROR: -- Marshal JSON -- %v\n&quot;, err)
           }
 
           ipvsString = string(ipvsJSONbyte)
           ipvsJSON = strings.Replace(ipvsString, `\n`, ``, -1)
           if debug != false {
               logToOut.Println(&quot;DEBUG: -- ipvsJSON --&quot;, ipvsJSON)
           }
       }
   }
}</code></div></pre>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">Next is the index handler, we set our headers correctly and print the result as we would receive through ipvsadm. The index is mainly for our platform engineers to debug and verify the output. Thanks to this overview we found much faster that there was a newline hidden in the scheduler output.</p>
<pre><div style="color:#f8f8f2;background:#272822;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em"><code class="language-go" style="color:#f8f8f2;background:none;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">func index() http.Handler {
   // Generating the Index
   return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {

       // Only available when debug is on
       if debug != false {
           logToOut.Println(&quot;DEBUG: -- index --&quot;, ipvsString)
       }
 
       if r.URL.Path != &quot;/&quot; {
           http.Error(w, http.StatusText(http.StatusNotFound), http.StatusNotFound)
           return
       }
       w.Header().Set(&quot;Content-Type&quot;, &quot;text/plain; charset=utf-8&quot;)
       // Site security testers expect this header to be set
       w.Header().Set(&quot;X-Content-Type-Options&quot;, &quot;nosniff&quot;)
       w.WriteHeader(http.StatusOK)
       fmt.Fprintln(w, ipvsString)
   })
}</code></div></pre>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">The JSON endpoint is what we use in the client communicate with the server.</p>
<pre><div style="color:#f8f8f2;background:#272822;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em"><code class="language-go" style="color:#f8f8f2;background:none;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">func jsonz() http.Handler {
   // Generating the Index
   return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {

       // Only available when debug is on
       if debug != false {
           logToOut.Println(&quot;DEBUG: -- jsonz --&quot;, ipvsJSON)
       }
 
       if r.URL.Path != &quot;/json&quot; {
           http.Error(w, http.StatusText(http.StatusNotFound), http.StatusNotFound)
           return
       }
       w.Header().Set(&quot;Content-Type&quot;, &quot;application/json; charset=utf-8&quot;)
       // Site security testers expect this header to be set
       w.Header().Set(&quot;X-Content-Type-Options&quot;, &quot;nosniff&quot;)
       w.WriteHeader(http.StatusOK)
       fmt.Fprintln(w, ipvsJSON)
   })
}</code></div></pre>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">We ask our Developers often to implement a basic health endpoint, in DCOS we use this to see if a service needs to be restarted. In our application we enable set the statusOK in the index or in the JSON endpoint.</p>
<pre><div style="color:#f8f8f2;background:#272822;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em"><code class="language-go" style="color:#f8f8f2;background:none;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">func healthz() http.Handler {
   // Generating the healthz endpoint
   return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
       if atomic.LoadInt32(&amp;healthy) == 1 {
           w.WriteHeader(http.StatusNoContent)
           return
       }
       w.WriteHeader(http.StatusServiceUnavailable)
   })
}</code></div></pre>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">In our logging and tracing functions we want to register the clients that are connecting, this gives us information where calls are coming from. It helps us debugging if we see weird behaviour.</p>
<pre><div style="color:#f8f8f2;background:#272822;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em"><code class="language-go" style="color:#f8f8f2;background:none;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">func tracing(nextRequestID func() string) func(http.Handler) http.Handler {
   // Tracing the http requests so its easier to check if server is reached
   return func(next http.Handler) http.Handler {
       return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
           requestID := r.Header.Get(&quot;X-Request-Id&quot;)
           if requestID == &quot;&quot; {
               requestID = nextRequestID()
           }
           ctx := context.WithValue(r.Context(), requestIDKey, requestID)
           w.Header().Set(&quot;X-Request-Id&quot;, requestID)
           next.ServeHTTP(w, r.WithContext(ctx))
       })
   }
}

func logging(logToOut *log.Logger) func(http.Handler) http.Handler {
   // Creating logging entry tracing the http requests
   return func(next http.Handler) http.Handler {
       return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
           defer func() {
               requestID, ok := r.Context().Value(requestIDKey).(string)
               if !ok {
                   requestID = &quot;unknown&quot;
               }
               logToOut.Println(requestID, r.Method, r.URL.Path, r.RemoteAddr, r.UserAgent())
           }()
           next.ServeHTTP(w, r)
       })
   }
}</code></div></pre>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">IPVS needs to be executed with root privileges, to ensure this is correct we get the userid and print it when starting the server.</p>
<pre><div style="color:#f8f8f2;background:#272822;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em"><code class="language-go" style="color:#f8f8f2;background:none;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">// getProcessOwner function is to see who is running the process. It needs to be a sudo / root user
func getProcessOwner() string {
   stdout, err := exec.Command(&quot;ps&quot;, &quot;-o&quot;, &quot;user=&quot;, &quot;-p&quot;, strconv.Itoa(os.Getpid())).Output()
   if err != nil {
       logToErr.Printf(&quot;ERROR: -- getProcessOwner -- %v\n&quot;, err)
       os.Exit(1)
   }
   return string(stdout)
}</code></div></pre>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">We added the init function to ensure we print results the moment the server starts up, if we would not do this it would take 10 seconds for the go channel to activate</p>
<pre><div style="color:#f8f8f2;background:#272822;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em"><code class="language-go" style="color:#f8f8f2;background:none;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">func init() {
   // Placing the Save and val in the init, else we will need to wait for channel to perform its first run
   listIpvs.Save()
   ipvsString = fmt.Sprintln(listIpvs.Services)
}</code></div></pre>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">In the main function, we set the configurable flags, such as debugging to show error messages. It proved useful during the creation of this tool to keep track and print output. If we would print the output at every call to our logs, our Elastic cluster would get thousands of logs that add little to no value.</p>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">We configure the listen port in the flags, we can use the portIndex from DCOS to assign a random port on the host to listen on. We also provided to print the version we are running. In our versioning, we use a constant to list the application semver version, we also provide the git-commit hash.
When we begin the server we print the version information, the port we listen on and the user running the process. We then start the server process with the go channel, in setting up the go channel we ensure that when the server stops we try to gracefully stop the server within a 30-second timeframe. Since our ipvsadm timer is 10 seconds it should be able to cleanly shutdown within that period.</p>
<h3 class="Text-module__text-default Text-module__u-font-h3">Docker build</h3>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">In the repository, we have included a Dockerfile and a script to build the Dockerfile. In this Dockerfile, we pass the git commit hash to the go install. This way we always get the Git Hash from our GitHub repo and we can use this information in our version output.</p>
<h3 class="Text-module__text-default Text-module__u-font-h3">DCOS service.json</h3>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">In the repository, we have provided the service.json file, since it is opinionated on using Traefik you might need to change it. But in this service.json you see how we set up Traefik, the health check, and port index. Since the Mesos UCR container has fewer abstractions and has fewer limited capabilities. We can run the IPVS server inside a UCR container and get all the output as if we were running this directly as root on the host machine.</p>
<h2 class="Text-module__text-default Text-module__u-font-h2">ipvs-client</h2>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">The IPVS client is the component we use in the Kubernetes environment. The client connects to the server and gets the IPVS entries from the IPVS server inside our DCOS cluster. It then adds these IPVS entries to each node in the Kubernetes cluster. You, therefore, need to run each client per Kubernetes node.</p>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">You can find the code from the IPVS client in our repository.</p>
<pre><div style="color:#f8f8f2;background:#272822;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em"><code class="language-go" style="color:#f8f8f2;background:none;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">func httpGet(remoteURL string) []byte {
   if debug != false {
       _, err := url.ParseRequestURI(remoteURL)
       if err != nil {
           panic(err)
       }
   }

   req, err := http.NewRequest(http.MethodGet, remoteURL, nil)
   if err != nil {
       logToErr.Fatalf(&quot;ERROR: -- new HTTP request -- %v&quot;, err)
   }

   ipvsClient := http.Client{
       Timeout: time.Second * 2, // Timeout after 2 seconds
   }
   req.Header.Set(&quot;User-Agent&quot;, &quot;go-ipvs-get \tversion: &quot;+version+&quot;\t Git Commit: &quot;+gitCommit)
   res, err := ipvsClient.Do(req)
   if err != nil {
       logToErr.Fatalf(&quot;ERROR: -- ipvsClient -- %v\n&quot;, err)
   }

   if res.Body != nil {
       defer res.Body.Close()
   }

   body, readErr := ioutil.ReadAll(res.Body)
   if readErr != nil {
       logToErr.Fatalf(&quot;ERROR: -- body -- %v\n&quot;, readErr)
   }

   return body
}</code></div></pre>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">In the httpGet function we can debug the URL and check if it is valid. Again we set the correct headers and retrieve the JSON body.</p>
<pre><div style="color:#f8f8f2;background:#272822;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em"><code class="language-go" style="color:#f8f8f2;background:none;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">func unmarshal(body []byte) []lvs.Service {

   res := &amp;responseObject{
       Services: listIpvs.Services,
   }

   jsonErr := json.Unmarshal(body, &amp;res)
   if jsonErr != nil {
       logToErr.Fatalf(&quot;ERROR: -- Unmarshal -- %v \n&quot;, jsonErr)
   }

   if debug != false {
       logToOut.Fatalf(&quot;DEBUG: -- res -- %v \n&quot;, res.Services)
   }

   r := res.Services

   return r
}</code></div></pre>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">In the unmarshal function we unmarshal the JSON and turn it in a slice of lvs.Service.</p>
<pre><div style="color:#f8f8f2;background:#272822;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em"><code class="language-go" style="color:#f8f8f2;background:none;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">func addServers(remoteAddr string) {
   body := httpGet(remoteAddr)
   jsonData := unmarshal(body)

   for i, v := range jsonData {
       if debug != false {
           logToOut.Printf(&quot;DEBUG: -- range jsonDATA --\n&quot;)
           logToOut.Printf(&quot;ipvsCount=%v, value=%v&quot;, i, v)
       }

       err := lvs.DefaultIpvs.AddService(v)
       if err != nil {
           logToErr.Printf(&quot;ERROR: -- AddService -- %v&quot;, err)
       }
 
       i++
       ipvsServerCount = float64(i)
   }
}</code></div></pre>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">In the addServers function we add the servers to IPVS.</p>
<pre><div style="color:#f8f8f2;background:#272822;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em"><code class="language-go" style="color:#f8f8f2;background:none;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">func clientChan(c chan bool) {
   logToOut.Println(&quot;Starting time based IPVS Admin add&quot;)

   pollInterval := 10
   timerCh := time.Tick(time.Duration(pollInterval) * time.Second)
   // Time based loop to generate Global variable
   for range timerCh {
       select {
       // when shutdown is received we break
       case &lt;-c:
           logToOut.Println(&quot;Received shutdown, stopping timer&quot;)
           break
       default:

           logToOut.Println(&quot;Clearing &amp; Adding servers...&quot;)
           // Before we add Servers we need to clear the existing list
           lvs.Clear()
           addServers(remoteAddr)
           if debug != false {
               logToOut.Printf(&quot;IPVS servers added:\t%v&quot;, ipvsServerCount)
           }
       }
   }
}</code></div></pre>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">Like we did in the IPVS server we create a go channel to poll every 10 seconds the server endpoint. We perform this to get at a set interval the IPVS entries.</p>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">Since we run the IPVS client as a binary directly on the Kubernetes hosts we build the binary with a few parameters we pass to the go build command. The binary we build with this command we host on an internal s3 bucket, we can download this binary with systemd unit files.</p>
<pre><div style="color:#f8f8f2;background:#272822;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em"><code class="language-bash" style="color:#f8f8f2;background:none;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">GOOS=linux
GOARCH=amd64
GIT_COMMIT=$(git rev-list -1 HEAD)

export GOOS
export GOARCH
export GIT_COMMIT

env GOOS=${GOOS} GOARCH=${GOARCH} go build -v -ldflags &quot;-X main.gitCommit=${GIT_COMMIT}&quot; .</code></div></pre>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">When we run the IPVS client we can verify if the IPVS routes are added by running the <code style="background:rgb(0,0,0, 0.1);padding:2px 4px;font-size:80%;color:#000">ipvsadm -L -n</code> command.</p>
<h3 class="Text-module__text-default Text-module__u-font-h3">Unit files</h3>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">Since IPVS is part of the Linux kernel it is hard to deploy this in a docker container, the capabilities are more restricted in Kubernetes. We decided to deploy the IPVS client on each host machine through a systemd unit file, the main reason was that we ran into restrictions that slowed us down and this is not a permanent solution. By adding the IPVS client on the machines alone does not make it possible for containers to use the IPVS routes. We needed to add NET_ADMIN capabilities to all containers using the l4lb loadbalancer locations and configure <code style="background:rgb(0,0,0, 0.1);padding:2px 4px;font-size:80%;color:#000">hostNetworking: true</code> in the Kubernetes pods.</p>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">We provided a deployment.yml file that runs a Ubuntu docker container with ipvsadm only installed extra. When the pods are deployed in this deployment you can use kubectl exec to get into the pod and run the <code style="background:rgb(0,0,0, 0.1);padding:2px 4px;font-size:80%;color:#000">ipvsadm -L -n</code> command.</p>
<h2 class="Text-module__text-default Text-module__u-font-h2">Vacancy at Vandebron</h2>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">We are looking for a platform engineer in Vandebron. As you can understand this is not a typical scenario we daily run across, but it is part of the workloads that we will support when working on our platform. Within Vandebron we try to use the best technology available, when it is not available we build it. Due to this as platform engineers, we have many interesting challenges and offer engineers to support further than only a strict domain. We support all components of our entire platform, regardless if it is a Linux kernel issue like this, involves setting up and maintaining a NoSQL cluster, or helping the business with something like requesting a certificate.</p>
<p class="Text-module__text-default Text-module__u-font-body" node="[object Object]">If you are interested in learning more about this position, take a look at our Vacancy and get in contact with us.
<a href="https://werkenbij.vandebron.nl/" node="[object Object]" style="color:inherit" target="_blank">https://werkenbij.vandebron.nl/</a></p></div></div></div><footer style="padding-top:30px;padding-bottom:30px;background-color:#363639"><div class="Container-module__container"><div class="Row-module__row Row-module__align-items-center" style="margin-bottom:15px"><div class="Col-module__col-box-sizing Col-module__col"><div><div style="cursor:pointer;user-select:none;display:flex;align-items:baseline"><svg width="140" viewBox="0 0 140 22" xmlns="http://www.w3.org/2000/svg"><path d="M9.569 21.109h-4.25L0 6.274h4.597l2.86 9.249 2.86-9.249h4.598L9.57 21.11m13.234-4.258a3.159 3.159 0 0 1 0-6.316 3.156 3.156 0 0 1 3.144 2.884v.543a3.157 3.157 0 0 1-3.144 2.889m3.2-9.81a7.38 7.38 0 1 0 0 13.3c.136.425.537.73 1.003.73h3.174V6.313h-3.174c-.466 0-.867.304-1.003.728m64.522 3.567a3.155 3.155 0 0 0-3.141 2.888v.542a3.155 3.155 0 0 0 3.14 2.885 3.16 3.16 0 0 0 3.165-3.157 3.163 3.163 0 0 0-3.164-3.158m0 10.536a7.337 7.337 0 0 1-3.195-.727 1.056 1.056 0 0 1-1.006.727h-3.171V0h4.23v7.09a7.377 7.377 0 0 1 10.522 6.676c.001 4.074-3.298 7.378-7.38 7.378m26.406-4.22a3.155 3.155 0 0 1-3.141-2.886v-.542a3.155 3.155 0 0 1 3.141-2.888 3.163 3.163 0 0 1 3.164 3.159 3.161 3.161 0 0 1-3.164 3.156m.012-10.511c-5.054 0-7.481 3.978-7.481 7.356v.025c0 3.402 2.427 7.38 7.48 7.38 5.054 0 7.48-3.978 7.48-7.38 0-3.403-2.426-7.381-7.48-7.381m-60.448 4.196a3.155 3.155 0 0 1 3.141 2.888v.542a3.156 3.156 0 0 1-3.141 2.885 3.16 3.16 0 0 1-3.165-3.157 3.163 3.163 0 0 1 3.165-3.158m0 10.536a7.377 7.377 0 0 1-7.381-7.378A7.377 7.377 0 0 1 59.635 7.09V0h4.23v21.144h-3.17c-.473 0-.866-.303-1.006-.727a7.342 7.342 0 0 1-3.195.727zm51.349-14.856v4.222a3.074 3.074 0 0 0-.244-.013c-1.64 0-3.138 1.057-3.138 2.585v8.025h-4.234V6.276h3.17c.473 0 .867.303 1.006.727a7.353 7.353 0 0 1 3.196-.727c.082 0 .162.01.244.012zm25.525 4.21c-1.467 0-2.348.886-2.348 2.584v8.09h-4.285V6.277h3.172c.472 0 .865.304 1.005.727a7.347 7.347 0 0 1 3.195-.727s1.239-.059 2.514.343c3.027.904 3.379 3.962 3.379 5.599v8.955h-4.284v-8.091c0-.883-.205-2.585-2.348-2.585zm-93.333 0c-1.467 0-2.348.886-2.348 2.584v8.09h-4.284V6.277h3.17c.474 0 .866.304 1.006.727a7.354 7.354 0 0 1 3.196-.727s1.239-.059 2.514.343c3.028.904 3.378 3.962 3.378 5.599v8.955h-4.284v-8.091c0-.883-.204-2.585-2.348-2.585zm36.24 1.755h-5.453c-.116-.003-.55-.055-.325-.637a3.336 3.336 0 0 1 6.134.093c.147.495-.246.541-.356.544m2.55-3.796c-1.308-1.384-3.145-2.214-5.284-2.214-4.254 0-7.324 3.598-7.324 7.5 0 4.15 3.398 7.398 7.399 7.398a6.789 6.789 0 0 0 3.976-1.258c1.183-.806 2.165-2.013 2.844-3.574h-4.278c-.503.73-1.208 1.31-2.542 1.31-1.635 0-3.045-.983-3.22-2.468h10.393c.327-2.566-.202-4.806-1.964-6.694" fill="#ffffff" fill-rule="evenodd"></path></svg> <span class="Text-module__text-default Text-module__u-font-h3 Text-module__u-font-color-green" style="font-size:28px;margin:0;line-height:auto">.tech</span></div></div></div></div><div class="Row-module__row Row-module__align-items-center"><div class="Col-module__col-box-sizing Col-module__col"><span class="Text-module__text-default" style="color:white">© Vandebron</span></div></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"content":"\nIn October 2020 D2IQ [announced](https://d2iq.com/blog/d2iq-takes-the-next-step-forward) that they are moving onwards with their Kubernetes offering. Vandebron has been a D2IQ customer for their DCOS offering, we were just in the middle of a migration of our first workloads to DCOS Enterprise. We have evaluated the D2IQ K8s offering and decided to go for another Kubernetes product. We had a few migrations over the years, we migrated from Azure to AWS, we migrated workloads from normal instances to spot instances and all these migrations were done with nearly any downtime. We plan to reduce the downtime to a couple of minutes this migration and this is a real challenge. The first challenge that we will discuss today: We want to pair our Kubernetes clusters to the DCOS/Mesos clusters, while we move a workload it should be able to connect to its dependencies in the DCOS cluster. We use DCOS for our NoSQL databases like Cassandra, internal data that we want to keep internal. Pairing DCOS and Kubernetes clusters enable us to reduce downtime, enabling us to switch back if we run into issues and move faster because it reduces complexity.\n\n## L4LB\n\nThe internal layer 4 load balancer DCOS provides is used in the majority of our workloads. When our data scientists schedule a spark driver, they connect to the spark dispatcher through the Layer 4 load balancer. Most of the DCOS frameworks use this Layer 4 load balancer as an internal service discovery tool, with Vandebron we use this layer 4 load balancer to communicate between services. In a default DCOS set up this load balancer responds on domain names like: `spark-dispatcher.marathon.l4lb.thisdcos.directory:7077`\n\nWhen we ping the spark dispatcher we get the following:\n\n```bash\nPING spark-dispatcher.marathon.l4lb.thisdcos.directory (11.155.161.35) 56(84) bytes of data.\n64 bytes from 11.155.161.35 (11.155.161.35): icmp_seq=1 ttl=64 time=0.024 ms\n```\n\nAfter some investigation we found out that this IP range is not actually on a network interface, it is a Linux kernel functionality called `IPVS`. With IPVS you can do layer 4 load balancing, you provide the target location and the location you want to respond on.\n\nWhen we search for the IP from the spark dispatcher with ipvsadm, we get 3 results:\n\n```bash\nsudo ipvsadm -L -n |grep --color '11.155.161.35\\|$'\nTCP  11.155.161.35:80 wlc\n  -\u003e 10.2.7.146:16827             Masq    1      0          0\nTCP  11.155.161.35:4040 wlc\n  -\u003e 10.2.7.146:16826             Masq    1      0          0\nTCP  11.155.161.35:7077 wlc\n  -\u003e 10.2.7.146:16825             Masq    1      0          0\n````\n\nAs you can see the IP `11.155.161.35` points towards `10.2.7.146`, even the ports are configured and forwarded. We can add our route with ipvsadm, to understand IPVS a bit better. For example:\n\n```bash\nsudo ipvsadm -A -t 1.2.3.4:80 -s wlc # we add the target server and assign the scheduler\nsudo ipvsadm -a -r 10.2.7.146:16825 -t 1.2.3.4:80 -m # we configure the real server and target server and configure Masquerading\ncurl 1.2.3.4:80\n{\n  \"action\" : \"ErrorResponse\",\n  \"message\" : \"Missing protocol version. Please submit requests through http://[host]:[port]/v1/submissions/...\",\n  \"serverSparkVersion\" : \"2.3.4\"\n}\n```\n\nThis results in that the spark dispatcher now also is available on `1.2.3.4:80`. As mentioned before we wanted to connect our DCOS and Kubernetes clusters, getting hundreds of entries from ipvsadm and manually adding them one by one didn’t sound appealing to us. Especially if you consider that sometimes services fail and run on a different port or different host after recovery, maintaining this by hand would be a nightmare. We therefore decided to build a tool to sync IPVS entries from DCOS to Kubernetes.\n\n## Stack\n\nWithin Vandebron we have our tech stack, we strongly believe it is good to eat your own dog food. When possible and when our use cases are similar we use the same tools as our Developers use. The parts of the stack we will be using are:\n\n- AWS ELB in front of Traefik 1.7\n- DCOS\n- Kubernetes\n\nWithin our platform team, we use Golang as our scripting language. Golang gives us the ability to build binary files with all the required libraries in the binary, we don’t have to install any packages, we do not even need to install Golang on the machine the application will be running on.\n\nIn our DCOS cluster we use Traefik 1.7, this version of Traefik only forwards HTTP requests. We decided to use Traefik to expose a JSON endpoint so we can gather the IPVS information from this location.\n\n## ipvs-server\n\nWithin our DCOS cluster we will expose the IPVS information through a JSON endpoint. We have built a tool for this to expose this information in multiple ways. In the next section, we are going to discuss some of the concepts and choices we made, we won’t deep dive into Go specifics. We have provided the entire code for this project in the examples directory of our GitHub repo:\n\u003chttps://github.com/Vandebron/tech-blog\u003e\n\nFirst, let’s discuss the library we use: \u003chttps://github.com/nanobox-io/golang-lvs\u003e. This library in its essence translates to ipvsadm commands, it helped save us time to implement this ourselves. There are some gotcha’s, such as newlines are not filtered out from the output. We solved this by cleaning up some of the data.\n\nIn the `childChan` function we create a go channel that is responsible for polling `ipvsadm` every 10 seconds and stores the result in a couple of variables we use in our HTTP endpoints. IPVS is a Linux kernel functionality and should be highly performant, we do not want to trigger kernel panics when the server gets overloaded with requests. We expect that every 10 seconds gives us accurate enough results, we can always lower this interval to ensure faster results. We also added in this function the string manipulation to ensure all the newlines were gone in the JSON output. The newline gave issues when we tried to add the IPVS scheduler entries.\n\n```go\nfunc childChan(c chan bool) {\n   fmt.Println(\"Starting time based IPVS Admin poll\")\n\n   pollInterval := 10\n   timerCh := time.Tick(time.Duration(pollInterval) * time.Second)\n   // Time based loop to generate Global variable\n   for range timerCh {\n       select {\n       // when shutdown is received we break\n       case \u003c-c:\n           fmt.Println(\"Received shutdown, stopping timer\")\n           break\n       default:\n           var err error\n           listIpvs.Save()\n           ipvsString = fmt.Sprintln(listIpvs.Services)\n\n           res := \u0026responseObject{\n               Services: listIpvs.Services,\n           }\n \n           ipvsJSONbyte, err := json.Marshal(res)\n           if err != nil {\n               logToErr.Printf(\"ERROR: -- Marshal JSON -- %v\\n\", err)\n           }\n \n           ipvsString = string(ipvsJSONbyte)\n           ipvsJSON = strings.Replace(ipvsString, `\\n`, ``, -1)\n           if debug != false {\n               logToOut.Println(\"DEBUG: -- ipvsJSON --\", ipvsJSON)\n           }\n       }\n   }\n}\n```\n\nNext is the index handler, we set our headers correctly and print the result as we would receive through ipvsadm. The index is mainly for our platform engineers to debug and verify the output. Thanks to this overview we found much faster that there was a newline hidden in the scheduler output.\n\n```go\nfunc index() http.Handler {\n   // Generating the Index\n   return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\n       // Only available when debug is on\n       if debug != false {\n           logToOut.Println(\"DEBUG: -- index --\", ipvsString)\n       }\n \n       if r.URL.Path != \"/\" {\n           http.Error(w, http.StatusText(http.StatusNotFound), http.StatusNotFound)\n           return\n       }\n       w.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n       // Site security testers expect this header to be set\n       w.Header().Set(\"X-Content-Type-Options\", \"nosniff\")\n       w.WriteHeader(http.StatusOK)\n       fmt.Fprintln(w, ipvsString)\n   })\n}\n```\n\nThe JSON endpoint is what we use in the client communicate with the server. \n\n```go\nfunc jsonz() http.Handler {\n   // Generating the Index\n   return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\n       // Only available when debug is on\n       if debug != false {\n           logToOut.Println(\"DEBUG: -- jsonz --\", ipvsJSON)\n       }\n \n       if r.URL.Path != \"/json\" {\n           http.Error(w, http.StatusText(http.StatusNotFound), http.StatusNotFound)\n           return\n       }\n       w.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n       // Site security testers expect this header to be set\n       w.Header().Set(\"X-Content-Type-Options\", \"nosniff\")\n       w.WriteHeader(http.StatusOK)\n       fmt.Fprintln(w, ipvsJSON)\n   })\n}\n```\n\nWe ask our Developers often to implement a basic health endpoint, in DCOS we use this to see if a service needs to be restarted. In our application we enable set the statusOK in the index or in the JSON endpoint.\n\n```go\nfunc healthz() http.Handler {\n   // Generating the healthz endpoint\n   return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n       if atomic.LoadInt32(\u0026healthy) == 1 {\n           w.WriteHeader(http.StatusNoContent)\n           return\n       }\n       w.WriteHeader(http.StatusServiceUnavailable)\n   })\n}\n```\n\nIn our logging and tracing functions we want to register the clients that are connecting, this gives us information where calls are coming from. It helps us debugging if we see weird behaviour.\n\n```go\nfunc tracing(nextRequestID func() string) func(http.Handler) http.Handler {\n   // Tracing the http requests so its easier to check if server is reached\n   return func(next http.Handler) http.Handler {\n       return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n           requestID := r.Header.Get(\"X-Request-Id\")\n           if requestID == \"\" {\n               requestID = nextRequestID()\n           }\n           ctx := context.WithValue(r.Context(), requestIDKey, requestID)\n           w.Header().Set(\"X-Request-Id\", requestID)\n           next.ServeHTTP(w, r.WithContext(ctx))\n       })\n   }\n}\n\nfunc logging(logToOut *log.Logger) func(http.Handler) http.Handler {\n   // Creating logging entry tracing the http requests\n   return func(next http.Handler) http.Handler {\n       return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n           defer func() {\n               requestID, ok := r.Context().Value(requestIDKey).(string)\n               if !ok {\n                   requestID = \"unknown\"\n               }\n               logToOut.Println(requestID, r.Method, r.URL.Path, r.RemoteAddr, r.UserAgent())\n           }()\n           next.ServeHTTP(w, r)\n       })\n   }\n}\n```\n\nIPVS needs to be executed with root privileges, to ensure this is correct we get the userid and print it when starting the server.\n\n```go\n// getProcessOwner function is to see who is running the process. It needs to be a sudo / root user\nfunc getProcessOwner() string {\n   stdout, err := exec.Command(\"ps\", \"-o\", \"user=\", \"-p\", strconv.Itoa(os.Getpid())).Output()\n   if err != nil {\n       logToErr.Printf(\"ERROR: -- getProcessOwner -- %v\\n\", err)\n       os.Exit(1)\n   }\n   return string(stdout)\n}\n```\n\nWe added the init function to ensure we print results the moment the server starts up, if we would not do this it would take 10 seconds for the go channel to activate\n\n```go\nfunc init() {\n   // Placing the Save and val in the init, else we will need to wait for channel to perform its first run\n   listIpvs.Save()\n   ipvsString = fmt.Sprintln(listIpvs.Services)\n}\n```\n\nIn the main function, we set the configurable flags, such as debugging to show error messages. It proved useful during the creation of this tool to keep track and print output. If we would print the output at every call to our logs, our Elastic cluster would get thousands of logs that add little to no value.\n\nWe configure the listen port in the flags, we can use the portIndex from DCOS to assign a random port on the host to listen on. We also provided to print the version we are running. In our versioning, we use a constant to list the application semver version, we also provide the git-commit hash.\nWhen we begin the server we print the version information, the port we listen on and the user running the process. We then start the server process with the go channel, in setting up the go channel we ensure that when the server stops we try to gracefully stop the server within a 30-second timeframe. Since our ipvsadm timer is 10 seconds it should be able to cleanly shutdown within that period.\n\n### Docker build\n\nIn the repository, we have included a Dockerfile and a script to build the Dockerfile. In this Dockerfile, we pass the git commit hash to the go install. This way we always get the Git Hash from our GitHub repo and we can use this information in our version output.\n\n### DCOS service.json\n\nIn the repository, we have provided the service.json file, since it is opinionated on using Traefik you might need to change it. But in this service.json you see how we set up Traefik, the health check, and port index. Since the Mesos UCR container has fewer abstractions and has fewer limited capabilities. We can run the IPVS server inside a UCR container and get all the output as if we were running this directly as root on the host machine.\n\n## ipvs-client\n\nThe IPVS client is the component we use in the Kubernetes environment. The client connects to the server and gets the IPVS entries from the IPVS server inside our DCOS cluster. It then adds these IPVS entries to each node in the Kubernetes cluster. You, therefore, need to run each client per Kubernetes node.\n\nYou can find the code from the IPVS client in our repository.\n\n```go\nfunc httpGet(remoteURL string) []byte {\n   if debug != false {\n       _, err := url.ParseRequestURI(remoteURL)\n       if err != nil {\n           panic(err)\n       }\n   }\n\n   req, err := http.NewRequest(http.MethodGet, remoteURL, nil)\n   if err != nil {\n       logToErr.Fatalf(\"ERROR: -- new HTTP request -- %v\", err)\n   }\n\n   ipvsClient := http.Client{\n       Timeout: time.Second * 2, // Timeout after 2 seconds\n   }\n   req.Header.Set(\"User-Agent\", \"go-ipvs-get \\tversion: \"+version+\"\\t Git Commit: \"+gitCommit)\n   res, err := ipvsClient.Do(req)\n   if err != nil {\n       logToErr.Fatalf(\"ERROR: -- ipvsClient -- %v\\n\", err)\n   }\n\n   if res.Body != nil {\n       defer res.Body.Close()\n   }\n\n   body, readErr := ioutil.ReadAll(res.Body)\n   if readErr != nil {\n       logToErr.Fatalf(\"ERROR: -- body -- %v\\n\", readErr)\n   }\n\n   return body\n}\n```\n\nIn the httpGet function we can debug the URL and check if it is valid. Again we set the correct headers and retrieve the JSON body.\n\n```go\nfunc unmarshal(body []byte) []lvs.Service {\n\n   res := \u0026responseObject{\n       Services: listIpvs.Services,\n   }\n\n   jsonErr := json.Unmarshal(body, \u0026res)\n   if jsonErr != nil {\n       logToErr.Fatalf(\"ERROR: -- Unmarshal -- %v \\n\", jsonErr)\n   }\n\n   if debug != false {\n       logToOut.Fatalf(\"DEBUG: -- res -- %v \\n\", res.Services)\n   }\n\n   r := res.Services\n\n   return r\n}\n```\n\nIn the unmarshal function we unmarshal the JSON and turn it in a slice of lvs.Service.\n\n```go\nfunc addServers(remoteAddr string) {\n   body := httpGet(remoteAddr)\n   jsonData := unmarshal(body)\n\n   for i, v := range jsonData {\n       if debug != false {\n           logToOut.Printf(\"DEBUG: -- range jsonDATA --\\n\")\n           logToOut.Printf(\"ipvsCount=%v, value=%v\", i, v)\n       }\n\n       err := lvs.DefaultIpvs.AddService(v)\n       if err != nil {\n           logToErr.Printf(\"ERROR: -- AddService -- %v\", err)\n       }\n \n       i++\n       ipvsServerCount = float64(i)\n   }\n}\n```\n\nIn the addServers function we add the servers to IPVS.\n\n```go\nfunc clientChan(c chan bool) {\n   logToOut.Println(\"Starting time based IPVS Admin add\")\n\n   pollInterval := 10\n   timerCh := time.Tick(time.Duration(pollInterval) * time.Second)\n   // Time based loop to generate Global variable\n   for range timerCh {\n       select {\n       // when shutdown is received we break\n       case \u003c-c:\n           logToOut.Println(\"Received shutdown, stopping timer\")\n           break\n       default:\n\n           logToOut.Println(\"Clearing \u0026 Adding servers...\")\n           // Before we add Servers we need to clear the existing list\n           lvs.Clear()\n           addServers(remoteAddr)\n           if debug != false {\n               logToOut.Printf(\"IPVS servers added:\\t%v\", ipvsServerCount)\n           }\n       }\n   }\n}\n```\n\nLike we did in the IPVS server we create a go channel to poll every 10 seconds the server endpoint. We perform this to get at a set interval the IPVS entries.\n\nSince we run the IPVS client as a binary directly on the Kubernetes hosts we build the binary with a few parameters we pass to the go build command. The binary we build with this command we host on an internal s3 bucket, we can download this binary with systemd unit files.\n\n```bash\nGOOS=linux\nGOARCH=amd64\nGIT_COMMIT=$(git rev-list -1 HEAD)\n\nexport GOOS\nexport GOARCH\nexport GIT_COMMIT\n\nenv GOOS=${GOOS} GOARCH=${GOARCH} go build -v -ldflags \"-X main.gitCommit=${GIT_COMMIT}\" .\n```\n\nWhen we run the IPVS client we can verify if the IPVS routes are added by running the `ipvsadm -L -n` command.\n\n### Unit files\n\nSince IPVS is part of the Linux kernel it is hard to deploy this in a docker container, the capabilities are more restricted in Kubernetes. We decided to deploy the IPVS client on each host machine through a systemd unit file, the main reason was that we ran into restrictions that slowed us down and this is not a permanent solution. By adding the IPVS client on the machines alone does not make it possible for containers to use the IPVS routes. We needed to add NET_ADMIN capabilities to all containers using the l4lb loadbalancer locations and configure `hostNetworking: true` in the Kubernetes pods.\n\nWe provided a deployment.yml file that runs a Ubuntu docker container with ipvsadm only installed extra. When the pods are deployed in this deployment you can use kubectl exec to get into the pod and run the `ipvsadm -L -n` command.\n\n## Vacancy at Vandebron\n\nWe are looking for a platform engineer in Vandebron. As you can understand this is not a typical scenario we daily run across, but it is part of the workloads that we will support when working on our platform. Within Vandebron we try to use the best technology available, when it is not available we build it. Due to this as platform engineers, we have many interesting challenges and offer engineers to support further than only a strict domain. We support all components of our entire platform, regardless if it is a Linux kernel issue like this, involves setting up and maintaining a NoSQL cluster, or helping the business with something like requesting a certificate.\n\nIf you are interested in learning more about this position, take a look at our Vacancy and get in contact with us.\n\u003chttps://werkenbij.vandebron.nl/\u003e\n","meta":{"title":"Migrating from DCOS to Kubernetes, dealing with the l4lb loadbalancer","description":"When you want minimal downtime, you need to build your own tools","createdAt":"Fri Mar 05 2021 00:00:00 GMT+0000 (Coordinated Universal Time)","coverImage":"images/migrating-dcos-kubernetes-l4lb.jpg","imageSource":"https://pixabay.com/users/praesentator-4372890/","tags":"Kubernetes, k8s, mesos, l4lb, ipvs, ipvsadm","author":"Rogier Dikkes","slug":"blog/migrating-dcos-kubernetes-l4lb","formattedDate":"5 maart 2021","date":"Fri Mar 05 2021 00:00:00 GMT+0000 (Coordinated Universal Time)"}}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"migrating-dcos-kubernetes-l4lb"},"buildId":"DGmLRqHg0dXt8_IJvewUh","assetPrefix":"/pr-preview/pr-33","isFallback":false,"gsp":true}</script><script nomodule="" src="/pr-preview/pr-33/_next/static/chunks/polyfills-28654a8145d7603786fc.js"></script><script src="/pr-preview/pr-33/_next/static/chunks/webpack-0b9cc56c94819e8023ea.js" async=""></script><script src="/pr-preview/pr-33/_next/static/chunks/framework.87b9127d6cd191ae1c9a.js" async=""></script><script src="/pr-preview/pr-33/_next/static/chunks/3ef630e34cd10ba68f9d468ac363ff81c534e1e9.e3444f50a0a795e3eeb2.js" async=""></script><script src="/pr-preview/pr-33/_next/static/chunks/main-419ac17f185f95278b96.js" async=""></script><script src="/pr-preview/pr-33/_next/static/chunks/7b9503d2.4af90216c47085b5c8e9.js" async=""></script><script src="/pr-preview/pr-33/_next/static/chunks/0357a89c.a83a6a4548b93404854d.js" async=""></script><script src="/pr-preview/pr-33/_next/static/chunks/226daff62b2d4bc1e9a7210a7f6000a544319a74.fbdd4d016a5c47ddc9db.js" async=""></script><script src="/pr-preview/pr-33/_next/static/chunks/pages/_app-fdd34d89c08fa14a1e57.js" async=""></script><script src="/pr-preview/pr-33/_next/static/chunks/1c49f5f00355f650bee3d37484f094be037a30fa.0c099ecf2acefc71ba39.js" async=""></script><script src="/pr-preview/pr-33/_next/static/chunks/pages/blog/%5Bslug%5D-d612e1337a48eb1a935c.js" async=""></script><script src="/pr-preview/pr-33/_next/static/DGmLRqHg0dXt8_IJvewUh/_buildManifest.js" async=""></script><script src="/pr-preview/pr-33/_next/static/DGmLRqHg0dXt8_IJvewUh/_ssgManifest.js" async=""></script></body></html>