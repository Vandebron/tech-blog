{"pageProps":{"post":{"content":"\n## The problem\n\nSlick  \n\nWish list\n * Near-zero downtime during database upgrades \n * Guaranteed consistency between Slick models and database schema\n * \n\n```scala\ncase class ChargePoint(\n    id: Long,\n    brand: String,\n    powerInKwh: Double,\n    installationDate: Option[LocalDate]\n)\n```\n\n\n```scala\nclass ChargePointTable(tag: Tag) extends Table[ChargePoint](tag, None, \"charge_point\") {\n  override def * = (id, brand, powerInKwh, installationDate) <> (ChargePoint.tupled, ChargePoint.unapply)\n\n  val id: Rep[Long]                            = column[Long](\"id\", O.AutoInc, O.PrimaryKey)\n  val brand: Rep[String]                       = column[String](\"brand\")\n  val powerInKwh: Rep[Double]                  = column[Double](\"power_in_kwh\")\n  val installationDate: Rep[Option[LocalDate]] = column[Option[LocalDate]](\"installation_date\")\n}\n```\n\n## The solution\n","meta":{"title":"Type safe database evolution","description":"How can we evolve our databases without losing type safety","createdAt":"Sat May 07 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","coverImage":"images/spin-up-kubernetes-on-macbook.jpg","imageSource":"https://pixabay.com/it/users/mari_sparrow-13090456/","tags":"Scala, Slick, Flyway","author":"Sam Theisens","slug":"blog/slick-and-flyway-type-safe-db-evolution","formattedDate":"7 mei 2022","date":"Sat May 07 2022 00:00:00 GMT+0000 (Coordinated Universal Time)"}}},"__N_SSG":true}