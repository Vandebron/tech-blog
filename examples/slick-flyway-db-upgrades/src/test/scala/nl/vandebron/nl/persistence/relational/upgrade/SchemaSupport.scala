package nl.vandebron.nl.persistence.relational.upgrade

import slick.dbio.Effect
import slick.jdbc.H2Profile.api._
import slick.jdbc.JdbcBackend
import slick.jdbc.meta._
import slick.lifted.TableQuery
import slick.relational.RelationalProfile
import slick.sql.FixedSqlAction

import scala.collection.mutable
import scala.concurrent.duration.Duration
import scala.concurrent.{Await, ExecutionContext, Future}

trait SchemaSupport {
  trait Entity {
    def identifier: String
    def typeName: String
  }

  case class PrimaryKey(p: MPrimaryKey) extends Entity {
    override def identifier: String = p.column + p.pkName.getOrElse("")

    override def typeName: String = "primary key"

    override def toString: String =
      s"ALTER TABLE ONLY ${p.table.schema.map(s => s"$s.").getOrElse("")}${p.table.name} ADD CONSTRAINT '${p.pkName
        .getOrElse("{name}")}' PRIMARY KEY (${p.column});"
  }

  object PrimaryKey {
    def fromSlick(p: MPrimaryKey) = PrimaryKey(p)
  }

  case class Column(c: MColumn) extends Entity {

    override def toString: String = {
      val nullable = if (!c.nullable.getOrElse(true)) { " NOT NULL" }
      else ""
      val autoInc = if (c.isAutoInc.getOrElse(false)) { " GENERATED BY DEFAULT AS IDENTITY" }
      else ""
      s"ALTER TABLE ${c.table.name} ADD COLUMN ${c.name} ${c.typeName}$autoInc$nullable"
    }

    override def identifier: String = c.name

    override def typeName: String = "column"

  }

  object Column {
    def fromSlick(c: MColumn) = Column(c.copy(columnDef = None, ordinalPosition = 1))
  }

  case class Index(i: MIndexInfo) extends Entity {
    override def identifier: String = i.column + i.indexName.getOrElse("")

    override def typeName: String = "index"

    override def toString: String = {
      val unique = if (i.nonUnique) " " else " UNIQUE "
      s"ALTER TABLE ONLY ${i.table.schema.map(s => s"$s.").getOrElse("")}${i.table.name} ADD CONSTRAINT '${i.indexName
        .getOrElse("{name}")}'$unique${i.column.map(c => s"($c)").getOrElse("")};"
    }
  }

  object Index {
    def fromSlick(i: MIndexInfo): Index = Index(i.copy(ordinalPosition = 1))
  }

  case class ForeignKey(fk: MForeignKey) extends Entity {
    override def identifier: String =
      fk.fkTable.name + fk.fkColumn + fk.fkName.getOrElse("")

    override def typeName: String = "foreign key"

    override def toString: String = {
      val deleteAction = if (fk.deleteRule.action.nonEmpty) s" ON DELETE ${fk.deleteRule.action}" else ""
      val updateAction = if (fk.updateRule.action.nonEmpty) s" ON UPDATE ${fk.updateRule.action}" else ""

      s"ALTER TABLE ONLY ${fk.fkTable.name} ADD CONSTRAINT " +
        s"'${fk.fkName.getOrElse("{name}")}' FOREIGN KEY (${fk.fkColumn}) REFERENCES ${fk.pkTable.schema
          .map(x => s"$x.")
          .getOrElse("")}${fk.pkTable.name}(${fk.pkColumn})$deleteAction$updateAction"
    }

  }

  object ForeignKey {
    def fromSlick(fk: MForeignKey) = ForeignKey(fk.copy(deferrability = 0, pkName = None))
  }

  def diffEntities[A <: Entity](thisSet: Seq[A], otherSet: Seq[A]): String = {
    val anyItem = (thisSet ++ otherSet).headOption
    if (anyItem.isEmpty) {
      return ""
    }
    val typeName = anyItem.get.typeName

    val result        = new mutable.StringBuilder
    val thisEntities  = thisSet.map(c => c.identifier -> c).toMap
    val otherEntities = otherSet.map(c => c.identifier -> c).toMap
    val bothEntities  = thisEntities.keySet.intersect(otherEntities.keySet)

    val inThisEntities  = thisEntities.filter(x => thisEntities.keySet.diff(otherEntities.keySet).contains(x._1))
    val inOtherEntities = otherEntities.filter(x => otherEntities.keySet.diff(thisEntities.keySet).contains(x._1))

    if (inThisEntities.nonEmpty) {
      inThisEntities.keySet.foreach(c => result.append(s"\nNew $typeName: ${inThisEntities(c).toString}"))
    }
    if (inOtherEntities.nonEmpty) {
      result.append(s"\nRemoved or renamed $typeName(s): ${inOtherEntities.keySet
        .mkString(", ")}.")
    }
    if (bothEntities.nonEmpty) {
      val fullyEqual = bothEntities.forall(c => thisEntities(c).equals(otherEntities(c)))
      if (!fullyEqual) result.append(s"\nAltered $typeName(s):")
      bothEntities.foreach { c: String =>
        val thisEntity  = thisEntities(c)
        val otherEntity = otherEntities(c)
        if (thisEntity != otherEntity) {
          if (thisEntity.toString == otherEntity.toString)
            result.append(s"\nðŸ˜± .toString is identical while .equals is not for $thisEntity")
          else result.append(s"\nSlick: $thisEntity, Flyway: $otherEntity")
        }
      }
    }
    result.result
  }

  case class Table(
      name: String,
      columns: Seq[Column],
      primaryKeys: Seq[PrimaryKey],
      foreignKeys: Seq[ForeignKey],
      indexes: Seq[Index]
  ) {
    def diff(other: Table): String = {
      val result = new mutable.StringBuilder(s"ðŸ‘‰ Table '$name'")

      result.append(diffEntities(columns, other.columns))
      result.append(diffEntities(primaryKeys, other.primaryKeys))
      result.append(diffEntities(foreignKeys, other.foreignKeys))
      result.append(diffEntities(indexes, other.indexes))

      result.result
    }
  }

  object Table {

    def fromSlick(c: MTable, columns: Seq[MColumn], primaryKeys: Seq[MPrimaryKey], foreign: Seq[MForeignKey], indexes: Seq[MIndexInfo]) =
      Table(
        name = c.name.name,
        columns = columns.map(Column.fromSlick).sortBy(_.identifier),
        primaryKeys = primaryKeys.map(PrimaryKey.fromSlick),
        foreignKeys = foreign.map(ForeignKey.fromSlick),
        indexes = indexes.map(Index.fromSlick)
      )
  }

  case class TableDefinition(
      tableName: String,
      action: FixedSqlAction[Unit, NoStream, Effect.Schema],
      ddl: Seq[String]
  )

  def getTableInfo(table: MTable, connection: JdbcBackend.DatabaseDef)(
      implicit ec: ExecutionContext
  ): Future[Table] =
    for {
      columns        <- connection.run(table.getColumns)
      primaryKeys    <- connection.run(table.getPrimaryKeys)
      foreignOutKeys <- connection.run(table.getExportedKeys)
      foreignInKeys  <- connection.run(table.getImportedKeys)
      indexes        <- connection.run(table.getIndexInfo())
    } yield Table.fromSlick(table, columns, primaryKeys, foreignOutKeys ++ foreignInKeys, indexes)

  def createSchema(
      connection: JdbcBackend.DatabaseDef,
      toCreate: Seq[TableQuery[RelationalProfile#Table[_]]],
      createDatabase: () => Int
  )(
      implicit ec: ExecutionContext
  ): Seq[TableDefinition] = {
    val databaseCreation = createDatabase()
    assert(databaseCreation == 0, s"Looks like database was not created with error code: $databaseCreation")
    val createSchemaFuture = for {
      tables <- connection.run(MTable.getTables)
      tableNames = tables.map(mt => mt.name.name)
      createIfNotExist = toCreate
        .filter(table => !tableNames.contains(table.baseTableRow.tableName))
        .map { t =>
          TableDefinition(t.baseTableRow.tableName, t.schema.create, t.schema.createIfNotExistsStatements.toSeq)
        }
      _ <- connection.run(DBIO.sequence(createIfNotExist.map(_.action)))
    } yield createIfNotExist
    val result = Await.result(createSchemaFuture, Duration.Inf)
    println(s"Created ${result.size} tables")
    result
  }

  def discoverSchema(connection: JdbcBackend.DatabaseDef, schemaMatch: String)(
      implicit ec: ExecutionContext
  ): Future[Map[String, Table]] =
    for {
      tables <- connection
        .run(MTable.getTables)
        .map { mTables =>
          mTables.filter { (t: MTable) =>
            t.tableType != "INDEX" && t.name.name != "primary" && !t.name.name.startsWith(
              "flyway_schema"
            )
          }
        }
      info <- Future.sequence(tables.map(getTableInfo(_, connection)))
    } yield info.map(t => t.name -> t).toMap
}
