package nl.vandebron.nl.persistence.relational.upgrade

import org.flywaydb.core.api.output.MigrateResult
import org.scalatest.concurrent.ScalaFutures.convertScalaFuture
import org.scalatest.matchers.should.Matchers
import org.scalatest.wordspec.AnyWordSpecLike
import slick.jdbc.H2Profile.api._
import slick.jdbc.JdbcBackend
import slick.lifted.TableQuery
import slick.relational.RelationalProfile

import scala.concurrent.ExecutionContext.Implicits.global

class SchemaRoundtripSpecs(
    db: JdbcBackend.DatabaseDef,
    toCreate: Seq[TableQuery[RelationalProfile#Table[_]]],
    createDatabase: () => Int,
    executeMigration: () => MigrateResult
) extends AnyWordSpecLike
    with SchemaSupport
    with Matchers {

  "Database" should {
    "match slick data types" in {
      println("Generating ddl from Slick Table definitions")
      val slickTableDefinitions = createSchema(db, toCreate, createDatabase).map(x => x.tableName -> x).toMap
      val schemaName            = "TESTDB"
      val slickMetadata         = discoverSchema(db, schemaName).futureValue

      db.run(sqlu"""DROP ALL OBJECTS;""").futureValue

      val executedMigration = executeMigration()
      val migrationsPath    = s"resources/db.$schemaName/migrations"
      assert(
        executedMigration.migrations.size() > 0,
        s"ðŸ™‹ï¸ Did not perform any migrations. Looks like no upgrade scripts could be found under $migrationsPath"
      )

      val flyWayMetadata: Map[String, Table] = discoverSchema(db, schemaName).futureValue

      val onlyInSlick  = slickMetadata.keySet.diff(flyWayMetadata.keySet)
      val onlyInFlyWay = flyWayMetadata.keySet.diff(slickMetadata.keySet)
      val inBoth       = slickMetadata.keySet.intersect(flyWayMetadata.keySet)

      if (onlyInSlick.nonEmpty) {
        println(s"\nðŸ’â€ Tables (${onlyInSlick.mkString(", ")}) have not been created by flyway")
        println(
          s"To guarantee consistency with the Flyway upgrade procedure, the following DDL can be copied into $migrationsPath/V1___baseline.sql"
        )
        onlyInSlick.foreach(table => slickTableDefinitions.get(table).foreach(t => println(t.ddl.mkString(";\n"))))
      }

      if (onlyInFlyWay.nonEmpty) {
        println(s"\nðŸ™‹â€ Tables (${onlyInFlyWay.mkString(", ")}) have no Slick counterpart. Should they be removed?")
        println("Consider creating V{x}___remove_outdated_tables.sql with the following lines")
        onlyInFlyWay.foreach(t => println(s"DROP TABLE IF EXISTS $t;"))
      }

      val differences = slickMetadata != flyWayMetadata
      if (inBoth.nonEmpty && differences) {
        println(s"\nðŸ™‹â€ Tables (${inBoth.mkString(", ")}) have discrepancies")

        inBoth.foreach { table =>
          val flywayTable = flyWayMetadata(table)
          val slickTable  = slickMetadata(table)
          if (!slickTable.equals(flywayTable)) {
            println(slickTable.diff(flywayTable))
            println("\nDDL generated by slick:")
            println(slickTableDefinitions(slickTable.name).ddl.mkString("\n"))
            println()
          }
        }
      }
      assert(!differences, "There should be no differences between tables generated by Slick or Flyway. See logs for details")
    }
  }

}
