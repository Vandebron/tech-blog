{"pageProps":{"post":{"content":"\n# Signing and verfiying SOAP messages with wss4j and Scala\n\nSOAP is not dead. It is an established, XML-based and mature messaging protocol that comes with built-in security mechanisms, integrity checks, content validation and much more. A lot of enterprises and corporations are using it (sadly) still.\nJust recently, Vandebron had to implement a SOAP client to communicate with an external party. \nThis blog post will explain with code examples how we at Vandebron are signing and verifying SOAP messages for our latest SOAP client implementation. \n\nFor this process, we are using Apache's Web Service Security Library [wss4j](https://ws.apache.org/wss4j/) as it is a proven tool in the WSS context and provides, as a Java library, great interoperability with the programming language Scala.\n\n## Signing SOAP messages\n\nHere we will take a look at the necessary steps to sign a SOAP message like this one:\n```xml\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\">\n  <soapenv:Header/>\n  <soapenv:Body>\n    <heading>Hello World</heading>\n    <body>I am just a test</body>\n  </soapenv:Body>\n</soapenv:Envelope>\n```\nTo look after signing like this:\n```xml\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\">\n  <soapenv:Header>\n    <wsse:Security \n    soapenv:mustUnderstand=\"1\" xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\" xmlns:wsse=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd\">\n      <ds:Signature \n      Id=\"SIG-ec946953-2470-4689-ad2f-0c579e1e06e3\" xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\">\n        <ds:SignedInfo>\n          <ds:CanonicalizationMethod Algorithm=\"http://www.w3.org/2001/10/xml-exc-c14n#\">\n            <ec:InclusiveNamespaces PrefixList=\"soapenv\" xmlns:ec=\"http://www.w3.org/2001/10/xml-exc-c14n#\"/>\n          </ds:CanonicalizationMethod>\n          <ds:SignatureMethod Algorithm=\"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\"/>\n          <ds:Reference URI=\"#id-47817454-f6e2-470c-9109-870e7895e3e0\">\n            <ds:Transforms>\n              <ds:Transform Algorithm=\"http://www.w3.org/2001/10/xml-exc-c14n#\"/>\n            </ds:Transforms>\n            <ds:DigestMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#sha256\"/>\n            <ds:DigestValue>7KfPcTwDYWtLj4ZVWmWmVqX4IGwbBAAmUPigCdXdk4U=</ds:DigestValue>\n          </ds:Reference>\n        </ds:SignedInfo>\n        <ds:SignatureValue>\n          OBnbBWv8S70xDDn5uG++7cTRFa2Uz3D47oxTHuO163Y3/V7H35M1GHXbKaUDOHsgsfx3SdVmVi++ra06cpwJknzqoIQgDV9Qc0ydzfxljCqupPKBnfONDYJtihEE1jtQ0RP7OLzPVNUpgOgHqbLwJu2pRUA05ool+lxIs924OwPVPKyUryoYwWhwY1ttY4P+WY2L3ZqsH3fgoLCyjlvhDEAhsP9PCxsEzPSq3ECC55Nh7nqMoHPj2uNxonuMlPeYbrlMnwyiqEW8s3Sc+WmfiIOgekRE1AdNhpn3ARlO490nObQtXCU/TxeTfbh98TMbQRZWWyT4HuLS3fF6aeyD/Q==\n        </ds:SignatureValue>\n        <ds:KeyInfo Id=\"KI-e18395de-9a26-4cad-9501-7c6cf6c7c74a\">\n          <wsse:SecurityTokenReference wsu:Id=\"STR-daa47836-f1f9-4d71-95cc-b7bcc6051c84\">\n            <wsse:KeyIdentifier \n            ValueType=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509SubjectKeyIdentifier\" EncodingType=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary\">\n              ox4ajWTdigy9oApTYs97CuCV/4k=\n            </wsse:KeyIdentifier>\n          </wsse:SecurityTokenReference>\n        </ds:KeyInfo>\n      </ds:Signature>\n    </wsse:Security>\n  </soapenv:Header>\n  <soapenv:Body \n    wsu:Id=\"id-47817454-f6e2-470c-9109-870e7895e3e0\" xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">\n      <heading>Hello World</heading>\n      <body>I am just a test</body>\n  </soapenv:Body>\n</soapenv:Envelope>\n```\n\nFor implementing the steps of the blog post you will need:\n- a SOAP service you want to send messages to\n- documentation of that SOAP service that describes:\n    - signature algorithm\n    - canonicalization method\n    - digest algorithm\n    - key identifier type\n- a private key with which you will sign your messages\n- a certificate that is the counterpart of the private key\n- (optional) a pool of trusted certificates\n\nOur private and public key pair are available in the PKCS#12-format (.p12 file extension). Check out [this](https://www.ssl.com/how-to/create-a-pfx-p12-certificate-file-using-openssl/) to learn more about this format and how to achieve it.\nThe pool of trusted certificates are in the [PKCS#7 format](https://www.ssl.com/guide/pem-der-crt-and-cer-x-509-encodings-and-conversions/) (.p7b file extension).\n\nFirst we have to setup the necessary dependencies:\n\n```scala\n   // in your build.sbt or project/Dependencies.scala\n  // enabling signing and signature verification for SOAP messages\n  lazy val webServiceSecurity = Seq(\n    \"org.apache.wss4j\" % \"wss4j\"                    % \"2.3.1\" pomOnly (),\n    \"org.apache.wss4j\" % \"wss4j-ws-security-dom\"    % \"2.3.1\",\n    \"org.apache.wss4j\" % \"wss4j-ws-security-common\" % \"2.3.1\"\n  )\n\n  libraryDependencies ++= webServiceSecurity\n```\n\nNext, we continue with a scala representation of our certificate we are using for signing:\n\n```scala\n  import org.apache.wss4j.dom.WSConstants\n  \n  // algorithm configuration\n  object SigningCertificate {\n    val CanonicalizationMethodURI: String = \"http://www.w3.org/2001/10/xml-exc-c14n#\"\n    val DigestAlgorithmURI: String        = DigestMethod.SHA256\n    val SignatureAlgorithmURI: String     = \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\"\n    val KeyIdentifierType: Int             = WSConstants.SKI_KEY_IDENTIFIER\n  }\n\n  case class SigningCertificate(keyStore: KeyStore, password: String) {\n    require(\n      keyStore.aliases().asScala.size == 1,\n      s\"Certificate of Keystore needs to have one alias but had ${keyStore.aliases().asScala.size}\"\n    )\n    val alias: String = keyStore.aliases().nextElement()\n\n    override def toString: String = s\"SigningCertificate(alias=$alias)\"\n  }\n```\nIn the documentation of the SOAP service that you want to call should stand some information regarding the canonicalization method, signature algorithm, digest algorithm, and the key identifier type. Those are algorithms and information that define the signing process and we explain roughly now.\n\nBefore signing a message it has to be canonicalized. \"Canonicalization is a method for generating a physical representation, the canonical form, of an XML document that accounts for syntactic changes permitted by the XML specification\" (from [here](https://www.di-mgt.com.au/xmldsig-c14n.html)). In our case, the Exclusive XML Canonicalization is used.\n\nThe digest algorithm is used to ensure the integrity of the message during the verification of a signature. The algorithm is used to calculate a hash of the signed message. It should be documented in the SOAP service documentation. Here we will use SHA256 as a hashing algorithm.\n\nThe signature algorithm describes how the message will be signed. It can be defined in the SOAP service documentation but in the worst case you can read this algorithm from the certificate itself by using [`keytool`](https://docs.oracle.com/en/java/javase/12/tools/keytool.html):\n```\n$ keytool -list -v -keystore signature.p12\nEnter keystore password: ...\n\n[...] # more information about the certificates\n\nSignature algorithm name: SHA256withRSA # thats what we are after!\n\n[...] # more information about the certificates\n```\nAccording to the keytool inspection we will use SHA256withRSA (http://www.w3.org/2001/04/xmldsig-more#rsa-sha256) for signing.\n\nLast but not least, in our signature, a `<KeyInfo>` element is included. This element contains information about the public key of the sender (us) and is needed for the signature verification once the message is received (read more [here](https://www.xml.com/pub/a/2001/08/08/xmldsig.html)). Since we have our public key provided we don't need to do much here. The `KeyIdentifierType` describes which form of key identifier is used to present the public key information.\n\nHaving all this information about our certificate in place, we build the mechanism to load in our signing certificate. For this, we create the object `KeyStoreBuilder`.\n\n```scala\nimport java.io.{File, FileInputStream}\n\nobject KeyStoreBuilder {\n\n  def loadSigningCertificate(signingCertificate: File, password: String): SigningCertificate = {\n    val fis = new FileInputStream(signingCertificate)\n    val ks: KeyStore               = KeyStore.getInstance(\"PKCS12\")\n    ks.load(fis, password.toCharArray)\n    SigningCertificate(ks, password)\n  } \n}\n```\nBear in mind, that you probably **don't** want to version any sensitive information like private keys and passwords hard-coded or in any environment variables, so a safe mechanism for storing/fetching passwords and certificates (like [Vault](https://www.hashicorp.com/products/vault)) should be in place.\n\nWith the signing certificate in place, we can actually start signing a message. The next code example contains quite some Java boilerplate from wss4j that is required to make the signing mechanism work.\n\nTo restrict the usage of Java classes to a small portion of our code we will firstly implement a conversion method `.toElem` inside of the companion object `SigningService`:\n\n```scala\n  import java.io.StringWriter\n  import javax.xml.transform.{OutputKeys, TransformerFactory}\n  import javax.xml.transform.dom.DOMSource\n  import javax.xml.transform.stream.StreamResult\n\n  import org.w3c.dom.Document\n\n  import scala.xml.Elem\n\n  object SigningService {\n    implicit class RichDocument(document: Document) {\n      private val tf = TransformerFactory.newInstance()\n\n      def toElem: Elem =\n        val transformer = tf.newTransformer()\n        transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n        val stringWriter = new StringWriter()\n        transformer.transform(new DOMSource(document), new StreamResult(stringWriter))\n        scala.xml.XML.loadString(stringWriter.getBuffer.toString)\n    }\n  }\n```\nWith that, we can convert any `Document` SOAP message representation back to the `scala.xml` supported  `Elem` format.\n\n```scala\nclass SigningService(signingCertificate: SigningCertificate) {\n\n  // importing our conversion method\n  import SigningService.RichDocument\n\n  /**\n    * REQUIRED, otherwise it will throw:\n    *\n    * org.apache.wss4j.common.ext.WSSecurityException:\n    * You must initialize the xml-security library correctly before you use it.\n    * Call the static method \"org.apache.xml.security.Init.init();\"\n    * to do that before you use any functionality from that library\n    */\n  org.apache.xml.security.Init.init()\n  \n  private val documentBuilderFactory = DocumentBuilderFactory.newInstance()\n  private val crypto: Merlin = getCrypto\n\n  crypto.setKeyStore(signingCertificate.keyStore)\n\n  def signElement(elem: Elem): Elem = {\n    documentBuilderFactory.setNamespaceAware(true)\n    // converting Elem to Document (Scala to Java conversion)\n    val doc = documentBuilderFactory.newDocumentBuilder().parse(new InputSource(new StringReader(elem.toString())))\n\n    // WSSecHeader wraps around the document we want to sign\n    val header = new WSSecHeader(doc)\n    header.setMustUnderstand(true)\n    header.insertSecurityHeader()\n\n    // start building Signature, use the (wrapper) header-instance\n    val builder = new WSSecSignature(header)\n    builder.setUserInfo(signingCertificate.alias, signingCertificate.password)\n\n    // setting algorithms\n    builder.setSignatureAlgorithm(SigningCertificate.SignatureAlgorithmURI)\n    builder.setSigCanonicalization(SigningCertificate.CanonicalizationMethodURI)\n    builder.setDigestAlgo(SigningCertificate.DigestAlgorithmURI)\n    builder.setKeyIdentifierType(SigningCertificate.KeyIdentifierType)\n    builder.setAddInclusivePrefixes(true)\n\n    // signing the document!\n    val signedDocument = builder.build(crypto)\n    // conversion back to Elem\n    signedDocument.toElem\n  }\n\n  private def getCrypto: Merlin = {\n    val properties = new Properties()\n    properties.setProperty(\"org.apache.wss4j.crypto.provider\", \"class org.apache.ws.security.components.crypto.Merlin\")\n    CryptoFactory.getInstance().asInstanceOf[Merlin]\n  }\n}\n```\n\nWss4j is a library that maintains an internal state during a signing process, but to avoid confusion it can be summarized as:\n1. `WSSecHeader` wraps around the document to be signed\n2. the WSSecHeader instance `header` will be used as part of the `WSSecSignature`-Builder\n3. the WSSecSignature instance `builder` gets configured with all necessary information, which algorithms are used for signing, digesting, canonicalization, which key identifier should be included. Those settings an vary from webservice to webservice.\n\nThe actual signing of the document, which is now nested like a matryoshka doll, is happening with the help of an instance of `Crypto`. `Crypto` will contain either a keystore or a truststore or even both. It needs to be specified in the `crypto.properties` file or a runtime which class of Crypto will be used.\n The most common one is [`Merlin`](https://ws.apache.org/wss4j/apidocs/org/apache/wss4j/common/crypto/Merlin.html).\nWe have decided to specify its configuration during runtime, since it is more visible than a properties file. Nevertheless, the `crypto.properties`-file needs to exist in your `resources` folder neverthless otherwise you will get a following `WSSecurityException`:\n```java\n  org.apache.wss4j.common.ext.WSSecurityException: No message with ID \"resourceNotFound\" found in resource bundle \"org/apache/xml/security/resource/xmlsecurity\"\n  [... rest of stacktrace ...]\n  Cause: java.nio.file.NoSuchFileException: crypto.properties\n```\n\nAnd that's it! The `KeyStoreBuilder` helps us to load a `SigningCertificate` and the `SigningService` uses this loaded certificate to sign SOAP messages. \nA receiver of our SOAP message has all the necessary information in our signature to verify that this message has not been tampered with and we are the original sender.\n\nThis verification is something we should also do on our side for incoming messages. So let's take a look at how we can verify the signature of received messages.\n\n## Verification of SOAP messages\n\nVerifying the signature of incoming messages is equally important to ensure that the connection is secure. A verification process will tell you if the message is coming from a trusted source and has not been tampered with.\n\nAs previously mentioned we need our source of truth, a pool of trusted public keys from all parties which will receive our SOAP messages. These build the basis of the trust store.\n\nWe will create a `TrustedCertificates` wrapper class in which we will load in the trust store and add this method to the `KeyStoreBuilder`.\n```scala\ncase class TrustedCertificates(keyStore: KeyStore)\n\nobject KeyStoreBuilder {\n\n    def loadTrustedCertificate(certificates: Seq[File]): TrustedCertificates = {\n    val ks = KeyStore.getInstance(KeyStore.getDefaultType)\n    // we just want the keystore to act as a truststore (only containing trusted certificates), so we initialize it empty\n    ks.load(null, null)\n    val cf = CertificateFactory.getInstance(\"X.509\")\n    certificates.foreach { file =>\n      CloseableUtil.using(getClass.getResourceAsStream(file.getPath)) { fis =>\n        val certPath = cf.generateCertPath(fis, \"PKCS7\")\n        certPath.getCertificates.asScala.toList.foreach { certificate =>\n          ks.setCertificateEntry(file.getName, certificate)\n        }\n      }\n    }\n    TrustedCertificates(ks)\n  }\n}\n```\nThis trust store is under the hood also just a KeyStore, without containing a private key that requires a password, that's why we can initialize the KeyStore with `null`-parameters.\n\nNow, the SigningService needs to be extended with this trusted certificates and a `verifySignatureOf`-method:\n\n```scala\nimport java.io.StringReader\nimport java.util.Properties\nimport javax.xml.parsers.DocumentBuilderFactory\n\nimport org.apache.wss4j.common.crypto.{ CryptoFactory, Merlin }\nimport org.apache.wss4j.dom.engine.WSSecurityEngine\nimport org.xml.sax.InputSource\n\nimport scala.util.{Failure, Success, Try}\nimport scala.xml.Elem\n\nclass SigningService(signingCertificate: SigningCertificate, trustedCertificates: TrustedCertificates) {\n\n    private val engine = new WSSecurityEngine()\n    private val documentBuilderFactory = DocumentBuilderFactory.newInstance()\n    private val crypto: Merlin = getCrypto\n\n    crypto.setKeyStore(signingCertificate.keyStore)\n    crypto.setTrustStore(trustedCertificates.keyStore)\n\n    def verifySignatureOf(elem: Elem): Boolean = {\n      documentBuilderFactory.setNamespaceAware(true)\n      val doc = documentBuilderFactory.newDocumentBuilder().parse(new InputSource(new StringReader(elem.toString())))\n\n      Try(engine.processSecurityHeader(doc, null, null, crypto)) match {\n        case Success(_) => true\n        case Failure(exception) =>\n          // replace with proper logging\n          println(\n            s\"Unsuccessful signature verification, it is most likely that the certificate used for signing is not in our Truststore: ${exception.getMessage}\")\n          false\n      }\n  }\n\n  private def getCrypto: Merlin = {\n    val properties = new Properties()\n    properties.setProperty(\"org.apache.wss4j.crypto.provider\", \"class org.apache.ws.security.components.crypto.Merlin\")\n    CryptoFactory.getInstance().asInstanceOf[Merlin]\n  }\n}\n```\n\nAnd with that, we have completed our roundtrip of signing and verifying SOAP messages!\n\nHere are gists, articles, and documentation that inspired and helped us to figure out the signing and verification process for our SOAP client. Feel free to check them out!\n\n* * *\n\n### Sources\n\n[WSSecurityVerifier by Luis Wolff](https://gist.github.com/luiswolff/1d388ec8c1d63cfb58974a6f826bc1be) \n\n[WSSecuritySigner by Luis Wolff](https://gist.github.com/luiswolff/64d15a99fbb5ec4b4e90eec04b09e053)\n\n[Unit Tests from ws-wss4j](https://github.com/apache/ws-wss4j/blob/master/ws-security-dom/src/test/java/org/apache/wss4j/dom/message/SignatureTest.java)\n\n[An Introduction to XML Digital Signatures](https://www.xml.com/pub/a/2001/08/08/xmldsig.html)\n\n[SOAP vs. REST](https://stackify.com/soap-vs-rest/)","meta":{"title":"Signing and verifying SOAP messages with wss4j and Scala","description":"This blogpost will explain with code examples how we at Vandebron are signing and verifying SOAP messages for our latest SOAP client implementation.","createdAt":"Mon Jun 28 2021 08:00:00 GMT+0800 (Singapore Standard Time)","coverImage":"images/soap.jpg","imageSource":"https://cdn.pixabay.com/photo/2020/03/15/18/36/wash-4934590_960_720.jpg","tags":"SOAP, xml, scala, wss4j, signature, verification","author":"Katrin Grunert","slug":"blog/how-to-sign-soap-messages","formattedDate":"28 juni 2021","date":"Mon Jun 28 2021 08:00:00 GMT+0800 (Singapore Standard Time)"}}},"__N_SSG":true}