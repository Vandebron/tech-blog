{"pageProps":{"post":{"content":"\nCypress is a game-changer in the automation testing world, the way that Cypress was built and its architecture allows us as testers to cover more scenarios.\n\nCypress is not Selenium; in fact, it is different. And the way to build and design a framework should be different as well.\n\nThe most famous design technique in Selenium is the Page Object Model, and many testers use the same design technique with Cypress. Even that Cypress on their official website [recommended](https://www.cypress.io/blog/2019/01/03/stop-using-page-objects-and-start-using-app-actions/) us not to go with that approach.\n\n## Page Object Model\n\nThe main benefit of using the page object model Is to make the automation framework maintenance-friendly. We can define a specific page's selectors in a separate file and then use these selectors in our test cases.\n\n```js\nclass SignInPage {\n  visit() {\n    cy.visit(\"/signin\");\n  }\n  getEmailError() {\n    return cy.get(`[data-testid=SignInEmailError]`);\n  }\n  getPasswordError() {\n    return cy.get(`[data-testid=SignInPasswordError]`);\n  }\n  fillEmail(value) {\n    const field = cy.get(`[data-testid=SignInEmailField]`);\n    field.clear();\n    field.type(value);\n    return this;\n  }\n  fillPassword(value) {\n    const field = cy.get(`[data-testid=SignInPasswordField]`);\n    field.clear();\n    field.type(value);\n    return this;\n  }\n  submit() {\n    const button = cy.get(`[data-testid=SignInSubmitButton]`);\n    button.click();\n  }\n}\nexport default SignInPage;\n```\n\nThe main two downsides using the typical page object model with cypress are:\n\n- Page objects introduce an additional state into the tests, separate from the applicationâ€™s internal state. This makes understanding the tests and failures harder.\n- Page objects make tests slow because they force the tests to always go through the application user interface.\n\n## Component-Based Architecture\n\nOn the other hand, a React application is component-based, where a specific page will be built from a collection of components. And components in React can be used on different pages too. So if we want to use the Page Object Model, we may define the same locator twice on different pages.\n\nSo having these two facts, At Vandebron, we came up with a new way to design our Cypress Automation framework by creating a separate JavaScript file for every component in our application, inside a folder called `components` within our Cypress project as below:\n\n```js\n// Locators\nexport const getEmailError = () => cy.get(`[data-testid=SignInEmailError]`);\nexport const getPasswordError = () =>\n  cy.get(`[data-testid=SignInPasswordError]`);\nexport const emailField = () => cy.get(`[data-testid=SignInEmailField]`);\nexport const passwordField = () => cy.get(`[data-testid=SignInPasswordField]`);\nexport const submitButton = () => cy.get(`[data-testid=SignInSubmitButton]`);\n\n// Actions\nexport const visit = () => cy.visit(\"/signin\");\nexport const performLogin = (email, password) => {\n  emailField().clear().type(email);\n  passwordField().clear().type(password);\n  submitButton().click();\n};\n```\n\nHaving it built this way, we eliminated all the previous problems mentioned earlier; we are not adding any classes, and we are defining objects within our test cases. And the most important part is that we are following the way that Cypress recommends it.\n\nAnd after defining the component locators and actions, we can import them inside our test case and use them as below:\n\n```js\nimport LoginComponent from \"../components/loginComponent\";\nimport Menu from \"../components/Menu\";\n\ndescribe(\"Test Login Page\", () => {\n  it(\"should show an error message if the password in wrong\", () => {\n    LoginComponent.visit();\n    LoginComponent.performLogin(\"email@gmail.com\", \"wrongPassword\");\n    LoginComponent.getPasswordError().should(\"be.visible\");\n  });\n  it(\"should show the logout button if the user logged in succesfully\", () => {\n    LoginComponent.visit();\n    LoginComponent.performLogin(\"email@gmail.com\", \"correctPassword\");\n    Menu.LogoutButton().should(\"be.visible\");\n  });\n});\n```\n\nAnd as you can see, our test cases are readable for anyone! And if any locator changes in any of the components, we can easily fix it in one location and from the same file. And lastly, if a component will be used in different places, we can use the same code.\n\nIn the next article, I will talk about how we use Cypress in our manual testing during the sprint and how it saves us tons of time and effort.\n","meta":{"title":"Cypress.io Component Design Technique for React Applications","description":"Cypress is a game-changer in the automation testing world, the way that Cypress was built and its architecture allows us as testers to cover more scenarios.","createdAt":"Fri Feb 05 2021 08:00:00 GMT+0800 (Central Indonesia Time)","coverImage":"images/cypress-component-design-technique-for-react-applications.png","tags":"Cypress, Testing, React","author":"Hatem Hatamleh","slug":"blog/cypress-component-design-technique-for-react-applications","formattedDate":"5 februari 2021","date":"Fri Feb 05 2021 08:00:00 GMT+0800 (Central Indonesia Time)"}}},"__N_SSG":true}